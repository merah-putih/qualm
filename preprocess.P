:- consult(list_utils).
:- consult(app_utils).

:- op(1110,xfy, '<-' ).         % Rule symbol
:- op(1110,fy, '<-' ).         % Rule symbol
:- op(600,fx,#).


:- import comma_to_list/2, memberchk/2, append/3, member/2 from basics.
:- import term_to_atom/2 from string.

% rule(Head,Body) and rule(RuleNr,Head,Body) are data structures to represent
% rules. RuleNr gives a number to a rule wrt. its occurrence (top to bottom)
:- dynamic rule/2, rule/3.

% lits(ListFluents) lists all fluents that can be incrementally updated in ListFluents
:- dynamic lits/1.

% flag ruleNames(N,N_ab,not_N,N_st) prepares various rule names
% needed in the transformation.
:- dynamic ruleNames/4.

% flag inBody(L) indicating that atom L is in the body of a rule
:- dynamic inBody/1. 

% flag hasRules(Pred,Arity) indicating that Pred/Arity has rules
:- dynamic hasRules/2. 

%==============================================================
% preprocessClauses(F,ProF) pre-processes the source program in F
% to transform it into rules with 'not make_not' and 'make' in their bodies.
preprocessClauses(File,ProFile) :-
	seeAbFile(File),
	tellPabFile(File,ProFile),
	processC,
	(intv(L) -> processI(L); true), %pre-process only if there is intv/1
	seen,
	told.

%==============================================================
%seeAbFile(F) opens for reading file F.ab
seeAbFile(FileName) :-
	append(FileName,".ab",FExt),
	name(F,FExt),
	see(F).

%==============================================================
% tellPabFile(F,ProF) opens for writing to file F.pab
tellPabFile(FileName,ProF) :-
	append(FileName,".pab",FExt),
	name(ProF,FExt),
	tell(ProF).

%==============================================================
% processC reads and pre-process each line in the source program 
processC :-
	read(C), 
	( C = end_of_file -> true; 
	processPred(C), processC
	). 

%==============================================================
% processI(L) creates rules for each member I of intv(L):
% I <- not make_not(I). %only for I without rules in the source program.
% I <- make(I).
processI(L) :-
	member(N/A,L),
	functor(I,N,A),
	(retract(hasRules(N,A)) -> true;
	 write(I), write(' <- '), write_list([not make_not(I)]), nl
	),
	write(I), write(' <- '), write_list([make(I)]), nl,
	fail.
processI(_).

%==============================================================
%processPred(C): pre-process each clause C in the source program
processPred(abds(L)) :- !,
	write(abds(L)), write('.'), nl, my_assert(abds(L)).

processPred(intv(L)) :- !,
	write(intv(L)), write('.'), nl, my_assert(intv(L)).

%process the Prolog part (within beginProlog and endProlog)
processPred(beginProlog) :- !,
	tell('prologAuxCode.P'),
	processProlog.


processPred((H <- B)) :- !,
	functor(H,ProH,Art),
	assertHasRules(ProH,Art),
	processRuleIntv(H,B). %add 'not make_not(H)' in the body, if applicable

processPred(( <- B)) :- !, processIC(B). %add 'false' in the head

processPred(C) :-
	functor(C,ProC,Art),
	assertHasRules(ProC,Art),
	write(C),
	intv_to_make(C,C1),
	(C1 = [] -> write('.');%C is not in intv/1
	 (write(' <- '), write_list(C1)) %C is in intv/1
	),
	nl.
%==============================================================
%processRuleIntv(H,B) adds to B 'not make_not(H)' if H is in intv/1
processRuleIntv(H,B) :- 
	comma_to_list(B,L),
	intv_to_make(H,H1),
	append(H1,L,B1),
	write(H), write(' <- '), write_list(B1), nl. 

%==============================================================
%processIC(B) adds false as the head of '<- B'
processIC(B) :- 
	comma_to_list(B, L), 
	write(false), write('<- '), write_list(L), nl. 


%==============================================================
%intv_to_make(P,L) constructs 'not make_not(P)' if P is in intv/1

intv_to_make(X,[not make_not(X)]) :- 
	is_interventable(X), !.
intv_to_make(_,[]).


%==============================================================
%loadPro(File) loads the transformation of pre-processed File
% into the Prolog database.
loadPro(ProFile) :-
	see(ProFile),
	loadClauses, %prepares each clause for loading to the database
	%processClauses, %transform each clause and loads it to the database
	seen.

%==============================================================
% loadClauses reads each clause in the pre-processed file,
% and prepares it for its loading to the database. 
loadClauses :-
    read(C),
    ( C = end_of_file -> true;
      ( loadClause(C), loadClauses ) ).

verifyLoadedClauses :-
	retract(has_facts(F,A)),
	(hasRules(F,A) -> true; assert(hasFacts(F,A))),
	fail.
verifyLoadedClauses :- nl.


%==============================================================
% loadClause(C) loads each clause C from the pre-processed file.
loadClause(abds(_)) :- !.
loadClause(intv(_)) :- !.

loadClause((Head <- B)) :- !,
	addToFluents(Head,G,Art,_),
	assertHasRules(G,Art),	
	comma_to_list(B,ListB),
        term_to_atom(Head,ProHead),
	term_to_atom(ListB,ProB),
	loadBody(B,LoadedB),
	assertRuleNames(G),
	assertIfNot(rule(Head,[('#(r)',[ProHead,ProB],_)|LoadedB])),
        assertIfNot(rule('#(r)'(ProHead,ProB),[])).

loadClause(Head) :-
	addToFluents(Head,G,Art,_),
	assertHasRules(G,Art),
	my_assert(rule(Head,[])).	

%==============================================================
%processProlog writes Prolog part (within beginProlog and endProlog)
%without any changes.
processProlog :-
	read(C),
	( C = end_of_file ->
		(seen, told, write('ERROR: missing endProlog'), nl, abort);
	  C = endProlog -> (told, ensure_loaded(prologAuxCode));
	  	(writeProlog(C), processProlog) ).

writeProlog(C) :- write(C), write('.'), nl.


makeFact(Head) :-
	addToFluents(Head,G,Art,Args),
	assertHasFacts(G,Art),
	Gluent =.. [G|Args],
	my_assert(rule(Gluent,[])).	


%==============================================================
% addToFluents(Lit,Pred,Arity,Args) adds to the list of fluents
% lits/1 the fluent predicate of Lit with its Arity, via
% the auxiliary predicate addToFluents/3.
addToFluents(H,G,Art,Args) :-
	collectPrefsArt(H,Art,G,Args),
	lits(Fs),
	(atom_concat('not_',Pref,G) -> true; Pref=G),
	addToFluents(Pref,Art,Fs).

%==============================================================
%addToFluent(Pred,Arity,LFluentPred) adds to the list of fluent
%LFluentPred the fluent predicate Pred/Arity, if not added yet.
%It also declared both Pred and its negation complement accordingly
%as dynamic incremental.
addToFluents(Pref,Art,Fs) :-
	memberchk(Pref/Art,Fs), !.
addToFluents(Pref,Art,Fs) :-
	retract(lits(Fs)),
	atom_compl(Pref,Pref_),
	my_incr_dyn(Pref,Art),
	my_incr_dyn(Pref_,Art),
	my_assert(lits([Pref/Art|Fs])).

%==============================================================
%loadBody(Body,ListBody) formats each literal L in Body into:
% (Predicate_L,Arguments_L,TS_Placeholder) and stores it in
% ListBody.
loadBody((prolog(P),B),[(prolog(P),_,_)|NA]) :- !,
	loadBody(B,NA).
loadBody(((not A),B),[(not PrefA,Args,_)|Rs]) :- !,
	assertInBody(A), %sets the flag inBody(A) that A is in a body of a rule
	addToFluents(A,PrefA,_,Args), %adds A into list of fluents 'lits'.
	loadBody(B,Rs).
loadBody((A,B),[(PrefA,Args,_)|Rs]) :- !,
	assertInBody(A),
	addToFluents(A,PrefA,_,Args), 
	loadBody(B,Rs).
loadBody(prolog(P),[(prolog(P),_,_)]) :- !.
loadBody((not A),[(not PrefA,Args,_)]) :- !,
	assertInBody(A),
	addToFluents(A,PrefA,_,Args).
loadBody(A,[(PrefA,Args,_)]) :-
	assertInBody(A),
	addToFluents(A,PrefA,_,Args).

%==============================================================
%assertHasRules(Pred,Arity) asserts hasRules(Pred,Arity), if
%not asserted yet
assertHasRules(H,A) :-
	assertIfNot(hasRules(H,A)).

assertHasAssertRules(H,A) :-
	assertIfNot(hasAssertRules(H,A)).


%==============================================================
% assertInBody(H) asserts flag inBody(HH), if not yet asserted,
% where HH is the template of H.
assertInBody(H) :-
	one_template(H,HH),
	assertIfNot(inBody(HH)).

assertHasFacts(H,A) :-
	assertIfNot(has_facts(H,A)).

%==============================================================
%assertRuleNames(N) asserts flag ruleNames(N,N_ab,not_N,N_st)
%to facilitate the construction of rules with those names.
assertRuleNames(N) :-
	renamePred("not_",N,[],NegN),
	renamePred([],N,"_ab",N_ab),
	renamePred([],N,"_st",N_st),
	assertIfNot(ruleNames(N,N_ab,NegN,N_st)).

%==============================================================


processClauses :-
	process_FailRules,
	process_Abds,
	tell('tabledAbCode.P'), %tabledAbCode.P will only contain rules '_ab'
	writeTableDecls, nl,
	process_Rules,
	told,
	process_AssertedRules.

%==============================================================
%process_FailRules adds to the database not_L(I,I,1,...) for
%atom L appearing in the body of a rule, but without any rule
%in the source program. The timstamp is 1 meaning it is added
%at the same time the program is inserted.
process_FailRules :-
	retract(inBody(L)),
	hasNoRules(L,Art,PredName),
	functor(PredName,Art,PredTempl),
	PredTempl =.. [PredName|Args],
	processLit(not(PredName),Args,I,I,1,PL),
	my_incr_assert(PL),
	fail.
process_FailRules.




%==============================================================
%hasNoRules(Lit,Arity,Pred) checks if Lit has no rules in the
%source program and returns its predicate name Pred and its Arity.
hasNoRules(H,A,L) :-
	collectPrefsArt(H,A,L,_),
	\+ hasRules(L,A), %no rules for L/A
	\+ is_abducible(H). %H is not an abducible

%==============================================================
%process_Abds/0 processes each abducible into a rule to insert it
%to the abductive context
process_Abds :-
	get_sol(abds(LAb),LAb),
	process_AbdRules(LAb).

%process_AbdRules(ListAbd) process each abducible A in ListAbd into
%a rule that insert A into the abductive context.
process_AbdRules([]).
process_AbdRules([AbPred/A|L]) :-
	functor(Ab,AbPred,A),
	Ab =.. [AbPred|AbArgs],
	renamePred("not_",AbPred,[],Not_AbPred),
	AbH =.. [AbPred,I,O,H|AbArgs],
	AbHNeg =.. [Not_AbPred,I,O,H|AbArgs],
	my_incr_assert((AbH :- insert(Ab,I,O))),
	my_incr_assert((AbHNeg :- insert(not(Ab),I,O))),
	process_AbdRules(L).

%==============================================================
%writeTableDecls/0 writes the declaration of tabled '_ab' predicates to
%the file tabledAbCode.P
writeTableDecls :-
	findTabledPred(Ps),
	writeTabledDecl(Ps).

findTabledPred(Ps) :-
	findall(Sig,findTPred(Sig),Ps).

findTPred(N_ab/NewA) :-
	hasRules(N,A),
	ruleNames(N,N_ab,_,_),
	NewA is A+2. %two additional parameters: abductive entry and timestamp.

writeTabledDecl([]).
writeTabledDecl([P|Ps]) :-
	write(':- table '), write(P), write(' as incremental.'), nl,
	writeTabledDecl(Ps).

%==============================================================
% process_Rules processes each rule of the following types:
% - PENDING

process_Rules :-
	retract(hasRules(H,A)),
	find_rules(H,A,R),
        process_tab_rules(R),
	process_pos_rule(H,A),
	process_neg_rule(H,A,R),
	process_star_rules(H,A,R),
	process_Rules.
process_Rules.


find_rules(H,A,R) :-
	functor(Head,H,A),
	index_rules(Head,1,R).

index_rules(Head,N,[rule(N,Head,Body)|Rs]) :-
	copy_term(Head,Head1),
	retract(rule(Head,Body)), !,
	my_assert(rule(N,Head,Body)),
	NewN is N+1,
	index_rules(Head1,NewN,Rs).
index_rules(_,_,[]).

/*
extract_abds(B,L_Abds,L_NAbds) :- extract_abds(B,[]*[],L_Abds,L_NAbds).

extract_abds([],A,A,[]).
extract_abds([(consider,[A],T)|Bs],PI*NI,AO,NA) :- !,
	A =.. [AbdL|AbdArg],
	TimedA =.. [AbdL,T|AbdArg],	
	insertElem(TimedA,PI,PO), 
	extract_abds(Bs,PO*NI,AO,NA).
extract_abds([(not consider,[A],T)|Bs],PI*NI,AO,NA) :- !,
	A =.. [AbdL|AbdArg],
	TimedA =.. [AbdL,T|AbdArg],	
	insertElem(not TimedA,NI,NO), 
	extract_abds(Bs,PI*NO,AO,NA).
extract_abds([B|Bs],AI,AO,[B|Cs]) :-
	extract_abds(Bs,AI,AO,Cs).
*/

extract_abds([],[],[]).
extract_abds([(consider,[A],T)|Bs],[(consider,[A],T)|Cs],NA) :- !,
	extract_abds(Bs,Cs,NA).
extract_abds([(not consider,[A],T)|Bs],[(not consider,[A],T)|Cs],NA) :- !,
	extract_abds(Bs,Cs,NA).
extract_abds([B|Bs],Cs,[B|Ns]) :-
	extract_abds(Bs,Cs,Ns).


process_tab_rules([]).
process_tab_rules([rule(_,H,B)|Rs]) :-
	extract_abds(B,Abds,NonAbds),
	append(Abds,NonAbds,ArrangeB),
	process_tab_rule(H,ArrangeB), 
	process_tab_rules(Rs).

process_tab_rule(H,[]) :- !,
	H =.. [Name|Args],
	ruleNames(Name,N_ab,_,_),
	ProH =.. [N_ab,[]*[],1|Args],
	write(ProH), writeln('.'),nl.
%	writeL([ProH, '.']).
	%my_incr_assert(ProH).	

/*
process_tab_rule(H,LAbds,[('#(r)',RuleName,TS)]) :- !, 
	H =.. [Name|Args],
	ruleNames(Name,N_ab,_,_),
	ProH =.. [N_ab,E,TS|Args],
	ProB =.. ['#(r)',LAbds,E,TS|RuleName],
	write(ProH), write(' :- '), writeq(ProB), writeln('.').
%	writeL([ProH, ' :- ', ProB, '.']).
%	my_incr_assert((ProH :- ProB)).
*/

process_tab_rule(H,B) :-
	H =.. [Name|Args],
	ruleNames(Name,N_ab,_,_),
	ProH =.. [N_ab,E,TS|Args],
	processBodyPos(B,[],Latest,ProB,[]*[],E,TS),
	write(ProH), write(' :- '), writeq(ProB), write(', '),
	writeq(Latest), writeln('.'),nl. 
%	writeL([ProH, ' :- ', ProB, ', ', Latest, '.']).
%	my_incr_assert((ProH :- ProB,Latest)).

processBodyPos([A],Ls,Latest,ProA,I,O,TS) :- !,
	processBodyLatest(A,L,ProA,I,O),
	Latest =.. [latest,[L|Ls],TS].

processBodyPos([A|B],Ls,Latest,(ProA,ProB),I,O,TS) :-
	processBodyLatest(A,L,ProA,I,OA),
	processBodyPos(B,[L|Ls],Latest,ProB,OA,O,TS).


process_pos_rule(H,A) :-
	makeList(A,Args),
	ProH =.. [H,I,O,T|Args],
	ruleNames(H,H_ab,_,_),
	ProTabledH =.. [H_ab,E,T|Args],
	my_incr_assert((ProH :- ProTabledH, produce(O,I,E))).
%	RuleProH = [ProH, ' :- ', ProTabledH, ', produce(', O, ', ', I, ', ', E, ').'],
%	writeL(RuleProH).


process_neg_rule(Name,A,R) :-
	ruleNames(Name,_,NegN,N_st),
	makeList(A,Args),
	processLit(NegN,Args,I,O,TS,ProH2),
	process_neg_body(N_st,Args,R,[I,O,TS],[],ProB2),
	my_incr_assert((ProH2 :- ProB2)).

process_neg_body(N_st,Args,[rule(N,_,_)],[I,O,TS],Ls,(B,Latest)) :- !,
	B =.. [N_st,N,LitDual,I,O|Args],
	 Latest =.. [latest,[LitDual|Ls],TS].
process_neg_body(N_st,Args,[rule(N,_,_)|Rs],[I,O,TS],Ls,(B,Bs)) :-
	B =.. [N_st,N,LitDual,I,OA|Args],
	process_neg_body(N_st,Args,Rs,[OA,O,TS],[LitDual|Ls],Bs).

process_star_rules(Name,A,R) :-
	ruleNames(Name,_,_,Name_st),
	makeList(A,Args),
	H =.. [Name|Args],
	process_diff_rules(Name_st,Args,H,R),
	process_dual_template(Name_st,Args,H).

process_diff_rules(_,_,_,[]).
process_diff_rules(Name_st,Args,Head,[rule(N,H,_)|Rs]) :-
	Head_st =.. [Name_st,N,_,I,I|Args],
	my_assert((Head_st :- Head \= H, !)),
	process_diff_rules(Name_st,Args,Head,Rs).

process_dual_template(Name_st,Args,Head) :-
	copy_term(Head,Head1),
	Head_st =.. [Name_st,N,LitDual,I,O|Args],
	my_assert((Head_st :- dual(N,Head1,Head,LitDual,I,O))).

process_AssertedRules :-
	ruleAs(Head,[(H,Arg,TS),Incr]),
	Head =.. [Name|ArgsHead],
	ProHead =.. [Name,I,O|ArgsHead],
	term_to_atom(H,HA),
	ProH =.. [HA,I,O,TS|Arg],
	my_incr_assert((ProHead :- ProH, Incr)),
	%my_incr_assert((ProHead :- fluent(HA,Arg,I,O,TS), Incr)),
	fail.
process_AssertedRules.	
